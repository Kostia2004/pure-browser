From: Mike Hommey <mh@glandium.org>
Date: Sat, 24 Dec 2011 09:56:58 +0100
Subject: Bug 691898 - Use YARR interpreter instead of PCRE on platforms where
 YARR JIT is not supported

---
 js/src/Makefile.in                         |   43 +++++++++++-----------------
 js/src/assembler/jit/ExecutableAllocator.h |    2 --
 js/src/vm/RegExpObject-inl.h               |   28 ++++--------------
 js/src/vm/RegExpObject.cpp                 |   37 ------------------------
 js/src/vm/RegExpObject.h                   |   33 +++++----------------
 js/src/yarr/wtfbridge.h                    |    2 --
 6 files changed, 29 insertions(+), 116 deletions(-)

diff --git a/js/src/Makefile.in b/js/src/Makefile.in
index 7defb97..e7a2eec 100644
--- a/js/src/Makefile.in
+++ b/js/src/Makefile.in
@@ -349,45 +349,20 @@ CPPSRCS += 	checks.cc \
 # END enclude sources for V8 dtoa
 #############################################
 
-# For architectures without YARR JIT, PCRE is faster than the YARR
-# interpreter (bug 684559).
-
-ifeq (,$(filter arm% sparc %86 x86_64 mips%,$(TARGET_CPU)))
-
-VPATH +=        $(srcdir)/yarr/pcre \
-		$(NULL)
-
-CPPSRCS += \
-                pcre_compile.cpp \
-                pcre_exec.cpp \
-                pcre_tables.cpp \
-                pcre_xclass.cpp \
-                pcre_ucp_searchfuncs.cpp \
-		$(NULL)
-else
-
 ###############################################
 # BEGIN include sources for the Nitro assembler
 #
 
-ENABLE_YARR_JIT = 1
-
 VPATH += 	$(srcdir)/assembler \
 		$(srcdir)/assembler/wtf \
 		$(srcdir)/assembler/jit \
-		$(srcdir)/assembler/assembler \
-		$(srcdir)/methodjit \
 		$(srcdir)/yarr \
 		$(NONE)
 
 CPPSRCS += 	Assertions.cpp \
 		ExecutableAllocator.cpp \
-		ARMAssembler.cpp \
-		MacroAssemblerARM.cpp \
-		MacroAssemblerX86Common.cpp \
 		PageBlock.cpp \
 		YarrInterpreter.cpp \
-		YarrJIT.cpp \
 		YarrPattern.cpp \
 		YarrSyntaxChecker.cpp \
 		$(NONE)
@@ -412,6 +387,19 @@ CPPSRCS += ExecutableAllocatorOS2.cpp \
            $(NONE)
 endif
 
+ifneq (,$(filter arm% sparc %86 x86_64 mips%,$(TARGET_CPU)))
+ENABLE_YARR_JIT = 1
+
+VPATH +=	$(srcdir)/assembler/assembler \
+		$(srcdir)/methodjit \
+		$(NONE)
+
+CPPSRCS +=	ARMAssembler.cpp \
+		MacroAssemblerARM.cpp \
+		MacroAssemblerX86Common.cpp \
+		YarrJIT.cpp \
+		$(NONE)
+
 ifeq (86, $(findstring 86,$(TARGET_CPU)))
 ifeq (x86_64, $(TARGET_CPU))
 #CPPSRCS		+= only_on_x86_64.cpp
@@ -422,12 +410,13 @@ endif
 ifeq (arm, $(TARGET_CPU))
 #CPPSRCS		+= only_on_arm.cpp
 endif
+
+endif
+
 #
 # END enclude sources for the Nitro assembler
 #############################################
 
-endif
-
 ifdef JS_HAS_CTYPES
 VPATH += $(srcdir)/ctypes
 
diff --git a/js/src/assembler/jit/ExecutableAllocator.h b/js/src/assembler/jit/ExecutableAllocator.h
index f1cf9d2..53233bc 100644
--- a/js/src/assembler/jit/ExecutableAllocator.h
+++ b/js/src/assembler/jit/ExecutableAllocator.h
@@ -445,8 +445,6 @@ public:
     {
         sync_instruction_memory((caddr_t)code, size);
     }
-#else
-    #error "The cacheFlush support is missing on this platform."
 #endif
 
 private:
diff --git a/js/src/vm/RegExpObject-inl.h b/js/src/vm/RegExpObject-inl.h
index 3c134d4..0d989b9 100644
--- a/js/src/vm/RegExpObject-inl.h
+++ b/js/src/vm/RegExpObject-inl.h
@@ -357,6 +357,7 @@ detail::RegExpPrivate::create(JSContext *cx, JSLinearString *source, RegExpFlag
     return RetType(priv);
 }
 
+#if ENABLE_YARR_JIT
 /* This function should be deleted once bad Android platforms phase out. See bug 604774. */
 inline bool
 detail::RegExpPrivateCode::isJITRuntimeEnabled(JSContext *cx)
@@ -367,12 +368,12 @@ detail::RegExpPrivateCode::isJITRuntimeEnabled(JSContext *cx)
     return true;
 #endif
 }
+#endif
 
 inline bool
 detail::RegExpPrivateCode::compile(JSContext *cx, JSLinearString &pattern, TokenStream *ts,
                                    uintN *parenCount, RegExpFlag flags)
 {
-#if ENABLE_YARR_JIT
     /* Parse the pattern. */
     ErrorCode yarrError;
     YarrPattern yarrPattern(pattern, bool(flags & IgnoreCaseFlag), bool(flags & MultilineFlag),
@@ -389,7 +390,7 @@ detail::RegExpPrivateCode::compile(JSContext *cx, JSLinearString &pattern, Token
      * case we have to bytecode compile it.
      */
 
-#ifdef JS_METHODJIT
+#if ENABLE_YARR_JIT && defined(JS_METHODJIT)
     if (isJITRuntimeEnabled(cx) && !yarrPattern.m_containsBackreferences) {
         JSC::ExecutableAllocator *execAlloc = cx->runtime->getExecutableAllocator(cx);
         if (!execAlloc) {
@@ -410,21 +411,11 @@ detail::RegExpPrivateCode::compile(JSContext *cx, JSLinearString &pattern, Token
         return false;
     }
 
+#if ENABLE_YARR_JIT
     codeBlock.setFallBack(true);
+#endif
     byteCode = byteCompile(yarrPattern, bumpAlloc).get();
     return true;
-#else /* !defined(ENABLE_YARR_JIT) */
-    int error = 0;
-    compiled = jsRegExpCompile(pattern.chars(), pattern.length(),
-                  ignoreCase() ? JSRegExpIgnoreCase : JSRegExpDoNotIgnoreCase,
-                  multiline() ? JSRegExpMultiline : JSRegExpSingleLine,
-                  parenCount, &error);
-    if (error) {
-        reportPCREError(cx, error);
-        return false;
-    }
-    return true;
-#endif
 }
 
 inline bool
@@ -466,19 +457,12 @@ detail::RegExpPrivateCode::execute(JSContext *cx, const jschar *chars, size_t le
     else
         result = JSC::Yarr::execute(codeBlock, chars, start, length, output);
 #else
-    result = jsRegExpExecute(cx, compiled, chars, length, start, output, outputCount);
+    result = JSC::Yarr::interpret(byteCode, chars, start, length, output);
 #endif
 
     if (result == -1)
         return RegExpRunStatus_Success_NotFound;
 
-#if !ENABLE_YARR_JIT
-    if (result < 0) {
-        reportPCREError(cx, result);
-        return RegExpRunStatus_Error;
-    }
-#endif
-
     JS_ASSERT(result >= 0);
     return RegExpRunStatus_Success;
 }
diff --git a/js/src/vm/RegExpObject.cpp b/js/src/vm/RegExpObject.cpp
index 938981a..e266828 100644
--- a/js/src/vm/RegExpObject.cpp
+++ b/js/src/vm/RegExpObject.cpp
@@ -392,7 +392,6 @@ Class js::RegExpClass = {
     regexp_trace
 };
 
-#if ENABLE_YARR_JIT
 void
 RegExpPrivateCode::reportYarrError(JSContext *cx, TokenStream *ts, ErrorCode error)
 {
@@ -424,42 +423,6 @@ RegExpPrivateCode::reportYarrError(JSContext *cx, TokenStream *ts, ErrorCode err
     }
 }
 
-#else /* !ENABLE_YARR_JIT */
-
-void
-RegExpPrivateCode::reportPCREError(JSContext *cx, int error)
-{
-#define REPORT(msg_) \
-    JS_ReportErrorFlagsAndNumberUC(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL, msg_); \
-    return
-    switch (error) {
-      case -2: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      case 0: JS_NOT_REACHED("Precondition violation: an error must have occurred.");
-      case 1: REPORT(JSMSG_TRAILING_SLASH);
-      case 2: REPORT(JSMSG_TRAILING_SLASH);
-      case 3: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      case 4: REPORT(JSMSG_BAD_QUANTIFIER);
-      case 5: REPORT(JSMSG_BAD_QUANTIFIER);
-      case 6: REPORT(JSMSG_BAD_CLASS_RANGE);
-      case 7: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      case 8: REPORT(JSMSG_BAD_CLASS_RANGE);
-      case 9: REPORT(JSMSG_BAD_QUANTIFIER);
-      case 10: REPORT(JSMSG_UNMATCHED_RIGHT_PAREN);
-      case 11: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      case 12: REPORT(JSMSG_UNMATCHED_RIGHT_PAREN);
-      case 13: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      case 14: REPORT(JSMSG_MISSING_PAREN);
-      case 15: REPORT(JSMSG_BAD_BACKREF);
-      case 16: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      case 17: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
-      default:
-        JS_NOT_REACHED("Precondition violation: unknown PCRE error code.");
-    }
-#undef REPORT
-}
-
-#endif /* ENABLE_YARR_JIT */
-
 bool
 js::ParseRegExpFlags(JSContext *cx, JSString *flagStr, RegExpFlag *flagsOut)
 {
diff --git a/js/src/vm/RegExpObject.h b/js/src/vm/RegExpObject.h
index 5b92599..5ce9119 100644
--- a/js/src/vm/RegExpObject.h
+++ b/js/src/vm/RegExpObject.h
@@ -51,10 +51,8 @@
 #include "yarr/Yarr.h"
 #if ENABLE_YARR_JIT
 #include "yarr/YarrJIT.h"
-#include "yarr/YarrSyntaxChecker.h"
-#else
-#include "yarr/pcre/pcre.h"
 #endif
+#include "yarr/YarrSyntaxChecker.h"
 
 namespace js {
 
@@ -242,68 +240,51 @@ static const jschar GreedyStarChars[] = {'.', '*'};
 /* Abstracts away the gross |RegExpPrivate| backend details. */
 class RegExpPrivateCode
 {
-#if ENABLE_YARR_JIT
     typedef JSC::Yarr::BytecodePattern BytecodePattern;
     typedef JSC::Yarr::ErrorCode ErrorCode;
+    typedef JSC::Yarr::YarrPattern YarrPattern;
+#if ENABLE_YARR_JIT
     typedef JSC::Yarr::JSGlobalData JSGlobalData;
     typedef JSC::Yarr::YarrCodeBlock YarrCodeBlock;
-    typedef JSC::Yarr::YarrPattern YarrPattern;
 
     /* Note: Native code is valid only if |codeBlock.isFallBack() == false|. */
     YarrCodeBlock   codeBlock;
-    BytecodePattern *byteCode;
-#else
-    JSRegExp        *compiled;
 #endif
+    BytecodePattern *byteCode;
 
   public:
     RegExpPrivateCode()
       :
 #if ENABLE_YARR_JIT
         codeBlock(),
-        byteCode(NULL)
-#else
-        compiled(NULL)
 #endif
+        byteCode(NULL)
     { }
 
     ~RegExpPrivateCode() {
 #if ENABLE_YARR_JIT
         codeBlock.release();
+#endif
         if (byteCode)
             Foreground::delete_<BytecodePattern>(byteCode);
-#else
-        if (compiled)
-            jsRegExpFree(compiled);
-#endif
     }
 
     static bool checkSyntax(JSContext *cx, TokenStream *tokenStream, JSLinearString *source) {
-#if ENABLE_YARR_JIT
         ErrorCode error = JSC::Yarr::checkSyntax(*source);
         if (error == JSC::Yarr::NoError)
             return true;
 
         reportYarrError(cx, tokenStream, error);
         return false;
-#else
-# error "Syntax checking not implemented for !ENABLE_YARR_JIT"
-#endif
     }
 
 #if ENABLE_YARR_JIT
     static inline bool isJITRuntimeEnabled(JSContext *cx);
-    static void reportYarrError(JSContext *cx, TokenStream *ts, JSC::Yarr::ErrorCode error);
-#else
-    static void reportPCREError(JSContext *cx, int error);
 #endif
+    static void reportYarrError(JSContext *cx, TokenStream *ts, JSC::Yarr::ErrorCode error);
 
     static size_t getOutputSize(size_t pairCount) {
-#if ENABLE_YARR_JIT
         return pairCount * 2;
-#else
-        return pairCount * 3; /* Should be x2, but PCRE has... needs. */
-#endif
     }
 
     inline bool compile(JSContext *cx, JSLinearString &pattern, TokenStream *ts, uintN *parenCount,
diff --git a/js/src/yarr/wtfbridge.h b/js/src/yarr/wtfbridge.h
index ac41d08..fb8eb86 100644
--- a/js/src/yarr/wtfbridge.h
+++ b/js/src/yarr/wtfbridge.h
@@ -49,9 +49,7 @@
 #include "jsprvtd.h"
 #include "vm/String.h"
 #include "assembler/wtf/Platform.h"
-#if ENABLE_YARR_JIT
 #include "assembler/jit/ExecutableAllocator.h"
-#endif
 
 namespace JSC { namespace Yarr {
 
