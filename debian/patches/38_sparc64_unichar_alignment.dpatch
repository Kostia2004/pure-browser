#! /bin/sh /usr/share/dpatch/dpatch-run
## 38_sparc64_unichar_alignment.dpatch by Mike Hommey <glandium@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Patch from bz#161826 to fix alignment issues on sparc64.

@DPATCH@

=== gfx/src/gtk/nsFontMetricsPango.cpp
==================================================================
--- xulrunner/gfx/src/gtk/nsFontMetricsPango.cpp	(revision 101)
+++ xulrunner/gfx/src/gtk/nsFontMetricsPango.cpp	(local)
@@ -532,11 +532,23 @@
                                       nsRenderingContextGTK *aContext)
 {
     nsresult rv = NS_OK;
-
+    gchar *text = NULL;
     PangoLayout *layout = pango_layout_new(mPangoContext);
 
-    gchar *text = g_utf16_to_utf8(aString, aLength,
-                                  NULL, NULL, NULL);
+    // Just copy the aString to ensure the alignment,
+    // it is not used anywhere else.
+    PRUnichar* dummy = (PRUnichar *) PR_Malloc(aLength*sizeof(PRUnichar));
+    if(!dummy) {
+#ifdef DEBUG
+        NS_WARNING("nsFontMetricsPango::GetTextDimensions malloc() failed");
+#endif
+        rv = NS_ERROR_FAILURE;
+        goto out;
+    }
+    memcpy(dummy, aString, aLength*sizeof(PRUnichar));
+    text = g_utf16_to_utf8(dummy, aLength,
+                           NULL, NULL, NULL);
+    PR_Free(dummy);
 
     if (!text) {
 #ifdef DEBUG
@@ -577,6 +589,7 @@
 
  loser:
     g_free(text);
+ out:
     g_object_unref(layout);
 
     return rv;
=== layout/generic/nsTextFrame.cpp
==================================================================
--- xulrunner/layout/generic/nsTextFrame.cpp	(revision 101)
+++ xulrunner/layout/generic/nsTextFrame.cpp	(local)
@@ -5101,8 +5101,8 @@
   
   while (aNumChars-- > 0) {
     // XXX: If you crash here then you may see the issue described
-    // in http://bugzilla.mozilla.org/show_bug.cgi?id=36146#c44
-    *cp2-- = PRUnichar(*cp1--);
+    // in http://bugzilla.mozilla.org/show_bug.cgi?id=161826
+    SetUnichar(cp2--, PRUnichar(*cp1--));
   }
 }
  
@@ -6199,9 +6199,9 @@
 {
   PRUnichar* end = aBuffer + aWordLen;
   for (; aBuffer < end; aBuffer++) {
-    PRUnichar ch = *aBuffer;
+    PRUnichar ch = GetUnichar(aBuffer);
     if (ch == ' ') {
-      *aBuffer = CH_NBSP;
+      SetUnichar(aBuffer, CH_NBSP);
     }
   }
 }
=== intl/lwbrk/src/nsJISx4501LineBreaker.cpp
==================================================================
--- xulrunner/intl/lwbrk/src/nsJISx4501LineBreaker.cpp	(revision 101)
+++ xulrunner/intl/lwbrk/src/nsJISx4501LineBreaker.cpp	(local)
@@ -487,13 +487,13 @@
   PRUint32 cur;
   for (cur = aPos; cur < aLen; ++cur)
   {
-    if (IS_SPACE(aText[cur]))
+    if (IS_SPACE(GetUnichar(&aText[cur])))
     {
       *oNext = cur;
       *oNeedMoreText = PR_FALSE;
       return NS_OK;
     }
-    if (IS_CJK_CHAR(aText[cur]))
+    if (IS_CJK_CHAR(GetUnichar(&aText[cur])))
       goto ROUTE_CJK_NEXT;
   }
   *oNext = aLen;
@@ -503,13 +503,13 @@
 ROUTE_CJK_NEXT:
   PRInt8 c1, c2;
   cur = aPos;
-  if(NEED_CONTEXTUAL_ANALYSIS(aText[cur]))
+  if(NEED_CONTEXTUAL_ANALYSIS(GetUnichar(&aText[cur])))
   {
-    c1 = this->ContextualAnalysis((cur>0)?aText[cur-1]:0,
-                                  aText[cur],
-                                  (cur<(aLen-1)) ?aText[cur+1]:0);
+    c1 = this->ContextualAnalysis((cur>0)?GetUnichar(&aText[cur-1]):0,
+                                  GetUnichar(&aText[cur]),
+                                  (cur<(aLen-1)) ?GetUnichar(&aText[cur+1]):0);
   } else  {
-    c1 = this->GetClass(aText[cur]);
+    c1 = this->GetClass(GetUnichar(&aText[cur]));
   }
   
   if(CLASS_THAI == c1) 
@@ -521,13 +521,13 @@
 
   for(cur++; cur <aLen; cur++)
   {
-     if(NEED_CONTEXTUAL_ANALYSIS(aText[cur]))
+     if(NEED_CONTEXTUAL_ANALYSIS(GetUnichar(&aText[cur])))
      {
-       c2= this->ContextualAnalysis((cur>0)?aText[cur-1]:0,
-                                  aText[cur],
-                                  (cur<(aLen-1)) ?aText[cur+1]:0);
+       c2= this->ContextualAnalysis((cur>0)?GetUnichar(&aText[cur-1]):0,
+                                  GetUnichar(&aText[cur]),
+                                  (cur<(aLen-1)) ?GetUnichar(&aText[cur+1]):0);
      } else {
-       c2 = this->GetClass(aText[cur]);
+       c2 = this->GetClass(GetUnichar(&aText[cur]));
      }
 
      if(GetPair(c1, c2)) {
=== intl/unicharutil/util/nsUnicharUtils.cpp
==================================================================
--- xulrunner/intl/unicharutil/util/nsUnicharUtils.cpp	(revision 101)
+++ xulrunner/intl/unicharutil/util/nsUnicharUtils.cpp	(local)
@@ -340,3 +340,28 @@
     return result;
 }
 
+PRUnichar
+GetUnichar(const void *ptr)
+{
+    PRUnichar result;
+#if NEED_STRICT_ALIGNMENT
+    *((char *) &result) = *((char *) ptr);
+    *((char *) &result + 1) = *((char *) ptr + 1);
+#else
+    result = *((PRUnichar *) ptr);
+#endif
+    return result;
+}
+
+void
+SetUnichar(void *ptr, PRUnichar aChar)
+{
+#if NEED_STRICT_ALIGNMENT
+    *((char *) ptr) = *((char *) &aChar);
+    *((char *) ptr + 1) = *((char *) &aChar + 1);
+#else
+    *((PRUnichar *) ptr) = aChar;
+#endif
+}
+
+
=== intl/unicharutil/util/nsUnicharUtils.h
==================================================================
--- xulrunner/intl/unicharutil/util/nsUnicharUtils.h	(revision 101)
+++ xulrunner/intl/unicharutil/util/nsUnicharUtils.h	(local)
@@ -82,6 +82,11 @@
 PRUnichar ToUpperCase(PRUnichar);
 PRUnichar ToLowerCase(PRUnichar);
 
+#define NEED_STRICT_ALIGNMENT defined(__sparc__) || defined(__alpha__) || defined(__mips__) || defined(__ia64)
+
+PRUnichar GetUnichar(const void *);
+void SetUnichar(void *, PRUnichar);
+
 inline PRBool IsUpperCase(PRUnichar c) {
     return ToLowerCase(c) != c;
 }
