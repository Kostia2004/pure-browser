From: Luke Wagner <luke@mozilla.com>
Date: Wed, 24 Aug 2011 14:28:28 -0700
Subject: Bug 589735 - Allow static JS strings to be turned off; turn off on
 ia64 (r=igor)

---
 js/src/jsgcinlines.h       |   12 +++++++
 js/src/jsnum.cpp           |    2 +
 js/src/jsstr.cpp           |    4 ++
 js/src/jsstr.h             |   16 +++++++--
 js/src/jsstrinlines.h      |   77 ++++++++++++++++++++++++++++++++++++++++++++
 js/src/jstracer.cpp        |    9 ++++-
 js/src/jstracer.h          |    2 +
 js/src/tracejit/Writer.cpp |    5 ++-
 8 files changed, 122 insertions(+), 5 deletions(-)

diff --git a/js/src/jsgcinlines.h b/js/src/jsgcinlines.h
index 538d0b9..b9dc0f7 100644
--- a/js/src/jsgcinlines.h
+++ b/js/src/jsgcinlines.h
@@ -59,6 +59,7 @@
 inline bool
 JSAtom::isUnitString(const void *ptr)
 {
+#ifdef JS_HAS_STATIC_STRINGS
     jsuword delta = reinterpret_cast<jsuword>(ptr) -
                     reinterpret_cast<jsuword>(unitStaticTable);
     if (delta >= UNIT_STATIC_LIMIT * sizeof(JSString))
@@ -67,11 +68,15 @@ JSAtom::isUnitString(const void *ptr)
     /* If ptr points inside the static array, it must be well-aligned. */
     JS_ASSERT(delta % sizeof(JSString) == 0);
     return true;
+#else
+    return false;
+#endif
 }
 
 inline bool
 JSAtom::isLength2String(const void *ptr)
 {
+#ifdef JS_HAS_STATIC_STRINGS
     jsuword delta = reinterpret_cast<jsuword>(ptr) -
                     reinterpret_cast<jsuword>(length2StaticTable);
     if (delta >= NUM_SMALL_CHARS * NUM_SMALL_CHARS * sizeof(JSString))
@@ -80,11 +85,15 @@ JSAtom::isLength2String(const void *ptr)
     /* If ptr points inside the static array, it must be well-aligned. */
     JS_ASSERT(delta % sizeof(JSString) == 0);
     return true;
+#else
+    return false;
+#endif
 }
 
 inline bool
 JSAtom::isHundredString(const void *ptr)
 {
+#ifdef JS_HAS_STATIC_STRINGS
     jsuword delta = reinterpret_cast<jsuword>(ptr) -
                     reinterpret_cast<jsuword>(hundredStaticTable);
     if (delta >= NUM_HUNDRED_STATICS * sizeof(JSString))
@@ -93,6 +102,9 @@ JSAtom::isHundredString(const void *ptr)
     /* If ptr points inside the static array, it must be well-aligned. */
     JS_ASSERT(delta % sizeof(JSString) == 0);
     return true;
+#else
+    return false;
+#endif
 }
 
 inline bool
diff --git a/js/src/jsnum.cpp b/js/src/jsnum.cpp
index 554c27d..90bfc9c 100644
--- a/js/src/jsnum.cpp
+++ b/js/src/jsnum.cpp
@@ -1187,6 +1187,7 @@ js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
     if (JSDOUBLE_IS_INT32(d, &i)) {
         if (base == 10 && JSAtom::hasIntStatic(i))
             return &JSAtom::intStatic(i);
+#ifdef JS_HAS_STATIC_STRINGS
         if (jsuint(i) < jsuint(base)) {
             if (i < 10)
                 return &JSAtom::intStatic(i);
@@ -1194,6 +1195,7 @@ js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
             JS_ASSERT(JSAtom::hasUnitStatic(c));
             return &JSAtom::unitStatic(c);
         }
+#endif
 
         if (JSFlatString *str = c->dtoaCache.lookup(base, d))
             return str;
diff --git a/js/src/jsstr.cpp b/js/src/jsstr.cpp
index 7269f23..4d01e5a 100644
--- a/js/src/jsstr.cpp
+++ b/js/src/jsstr.cpp
@@ -3244,6 +3244,8 @@ static JSFunctionSpec string_methods[] = {
     JS_FS_END
 };
 
+#ifdef JS_HAS_STATIC_STRINGS
+
 /*
  * Set up some tools to make it easier to generate large tables. After constant
  * folding, for each n, Rn(0) is the comma-separated list R(0), R(1), ..., R(2^n-1).
@@ -3438,6 +3440,8 @@ const JSString::Data *const JSAtom::intStaticTable[] = { R8(0) };
 #undef R3
 #undef R7
 
+#endif  /* defined(JS_HAS_STATIC_STRINGS) */
+
 JSBool
 js_String(JSContext *cx, uintN argc, Value *vp)
 {
diff --git a/js/src/jsstr.h b/js/src/jsstr.h
index 0977fca..3e0dbfd 100644
--- a/js/src/jsstr.h
+++ b/js/src/jsstr.h
@@ -601,24 +601,34 @@ class JSExternalString : public JSFixedString
 
 JS_STATIC_ASSERT(sizeof(JSExternalString) == sizeof(JSString));
 
+#if !defined(__ia64__)
+/*
+ * Don't use static strings on ia64 since the compiler may put the static
+ * memory out of the acceptable 47-bit jsval pointer range.
+ */
+# define JS_HAS_STATIC_STRINGS
+#endif
+
 class JSAtom : public JSFixedString
 {
   public:
     /* Exposed only for jits. */
 
+#ifdef JS_HAS_STATIC_STRINGS
     static const size_t UNIT_STATIC_LIMIT   = 256U;
     static const size_t SMALL_CHAR_LIMIT    = 128U; /* Bigger chars cannot be in a length-2 string. */
     static const size_t NUM_SMALL_CHARS     = 64U;
     static const size_t INT_STATIC_LIMIT    = 256U;
     static const size_t NUM_HUNDRED_STATICS = 156U;
 
-#ifdef __SUNPRO_CC
-# pragma align 8 (__1cGJSAtomPunitStaticTable_, __1cGJSAtomSlength2StaticTable_, __1cGJSAtomShundredStaticTable_)
-#endif
+# ifdef __SUNPRO_CC
+#  pragma align 8 (__1cGJSAtomPunitStaticTable_, __1cGJSAtomSlength2StaticTable_, __1cGJSAtomShundredStaticTable_)
+# endif
     static const JSString::Data unitStaticTable[];
     static const JSString::Data length2StaticTable[];
     static const JSString::Data hundredStaticTable[];
     static const JSString::Data *const intStaticTable[];
+#endif
 
   private:
     /* Defined in jsgcinlines.h */
diff --git a/js/src/jsstrinlines.h b/js/src/jsstrinlines.h
index c08e1ea..8c2ef62 100644
--- a/js/src/jsstrinlines.h
+++ b/js/src/jsstrinlines.h
@@ -412,6 +412,7 @@ JSExternalString::new_(JSContext *cx, const jschar *chars, size_t length, intN t
     return str;
 }
 
+#ifdef JS_HAS_STATIC_STRINGS
 inline bool
 JSAtom::fitsInSmallChar(jschar c)
 {
@@ -510,6 +511,82 @@ JSAtom::lookupStatic(const jschar *chars, size_t length)
     return NULL;
 }
 
+#else  /* defined(JS_HAS_STATIC_STRINGS) */
+
+inline bool
+JSAtom::fitsInSmallChar(jschar c)
+{
+    return false;
+}
+
+inline bool
+JSAtom::hasUnitStatic(jschar c)
+{
+    return false;
+}
+
+inline JSStaticAtom &
+JSAtom::unitStatic(jschar c)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline bool
+JSAtom::hasUintStatic(uint32 u)
+{
+    return false;
+}
+
+inline JSStaticAtom &
+JSAtom::uintStatic(uint32 u)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline bool
+JSAtom::hasIntStatic(int32 i)
+{
+    return false;
+}
+
+inline JSStaticAtom &
+JSAtom::intStatic(jsint i)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline JSLinearString *
+JSAtom::getUnitStringForElement(JSContext *cx, JSString *str, size_t index)
+{
+    JS_ASSERT(index < str->length());
+    return js_NewDependentString(cx, str, index, 1);
+}
+
+inline JSStaticAtom &
+JSAtom::length2Static(jschar c1, jschar c2)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline JSStaticAtom &
+JSAtom::length2Static(uint32 i)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+/* Get a static atomized string for chars if possible. */
+inline JSStaticAtom *
+JSAtom::lookupStatic(const jschar *chars, size_t length)
+{
+    return NULL;
+}
+#endif /* defined(JS_HAS_STATIC_STRINGS) */
+
 JS_ALWAYS_INLINE void
 JSString::finalize(JSContext *cx)
 {
diff --git a/js/src/jstracer.cpp b/js/src/jstracer.cpp
index 429ccc1..f9dd9f6 100644
--- a/js/src/jstracer.cpp
+++ b/js/src/jstracer.cpp
@@ -11378,6 +11378,7 @@ TraceRecorder::callNative(uintN argc, JSOp mode)
             }
             if (vp[1].isString()) {
                 JSString *str = vp[1].toString();
+#ifdef JS_HAS_STATIC_STRINGS
                 if (native == js_str_charAt) {
                     jsdouble i = vp[2].toNumber();
                     if (JSDOUBLE_IS_NaN(i))
@@ -11391,7 +11392,9 @@ TraceRecorder::callNative(uintN argc, JSOp mode)
                     set(&vp[0], char_ins);
                     pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
                     return RECORD_CONTINUE;
-                } else if (native == js_str_charCodeAt) {
+                } else
+#endif
+                if (native == js_str_charCodeAt) {
                     jsdouble i = vp[2].toNumber();
                     if (JSDOUBLE_IS_NaN(i))
                       i = 0;
@@ -12818,6 +12821,7 @@ TraceRecorder::getCharCodeAt(JSString *str, LIns* str_ins, LIns* idx_ins, LIns**
 JS_STATIC_ASSERT(sizeof(JSString) == 16 || sizeof(JSString) == 32);
 
 
+#ifdef JS_HAS_STATIC_STRINGS
 JS_REQUIRES_STACK LIns*
 TraceRecorder::getUnitString(LIns* str_ins, LIns* idx_ins)
 {
@@ -12862,6 +12866,7 @@ TraceRecorder::getCharAt(JSString *str, LIns* str_ins, LIns* idx_ins, JSOp mode,
     }
     return RECORD_CONTINUE;
 }
+#endif
 
 // Typed array tracing depends on EXPANDED_LOADSTORE and F2I
 #if NJ_EXPANDED_LOADSTORE_SUPPORTED && NJ_F2I_SUPPORTED
@@ -12896,6 +12901,7 @@ TraceRecorder::record_JSOP_GETELEM()
     LIns* obj_ins = get(&lval);
     LIns* idx_ins = get(&idx);
 
+#ifdef JS_HAS_STATIC_STRINGS
     // Special case for array-like access of strings.
     if (lval.isString() && hasInt32Repr(idx)) {
         if (call)
@@ -12908,6 +12914,7 @@ TraceRecorder::record_JSOP_GETELEM()
         set(&lval, char_ins);
         return ARECORD_CONTINUE;
     }
+#endif
 
     if (lval.isPrimitive())
         RETURN_STOP_A("JSOP_GETLEM on a primitive");
diff --git a/js/src/jstracer.h b/js/src/jstracer.h
index 8a0291e..2e9a7ea 100644
--- a/js/src/jstracer.h
+++ b/js/src/jstracer.h
@@ -1392,10 +1392,12 @@ class TraceRecorder
     JS_REQUIRES_STACK RecordingStatus getCharCodeAt(JSString *str,
                                                     nanojit::LIns* str_ins, nanojit::LIns* idx_ins,
                                                     nanojit::LIns** out_ins);
+#ifdef JS_HAS_STATIC_STRINGS
     JS_REQUIRES_STACK nanojit::LIns* getUnitString(nanojit::LIns* str_ins, nanojit::LIns* idx_ins);
     JS_REQUIRES_STACK RecordingStatus getCharAt(JSString *str,
                                                 nanojit::LIns* str_ins, nanojit::LIns* idx_ins,
                                                 JSOp mode, nanojit::LIns** out_ins);
+#endif
 
     JS_REQUIRES_STACK RecordingStatus initOrSetPropertyByName(nanojit::LIns* obj_ins,
                                                               Value* idvalp, Value* rvalp,
diff --git a/js/src/tracejit/Writer.cpp b/js/src/tracejit/Writer.cpp
index 0099d30..58671c4 100644
--- a/js/src/tracejit/Writer.cpp
+++ b/js/src/tracejit/Writer.cpp
@@ -249,7 +249,9 @@ couldBeObjectOrString(LIns *ins)
         // ins = andq ins_oprnd1, ins_oprnd2
         ret = true;
 #endif
-    } else if (ins->isop(LIR_addp) &&
+    }
+#ifdef JS_HAS_STATIC_STRINGS
+    else if (ins->isop(LIR_addp) &&
                ((ins->oprnd1()->isImmP() &&
                  (void *)ins->oprnd1()->immP() == JSAtom::unitStaticTable) ||
                 (ins->oprnd2()->isImmP() &&
@@ -261,6 +263,7 @@ couldBeObjectOrString(LIns *ins)
         // ins = addp JSString::unitStringTable, ...
         ret = true;
     }
+#endif
 
     return ret;
 }
