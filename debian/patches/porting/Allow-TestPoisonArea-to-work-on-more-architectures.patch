From: Mike Hommey <mh@glandium.org>
Date: Sat, 30 Oct 2010 09:56:52 +0200
Subject: Allow TestPoisonArea to work on more architectures

---
 layout/base/tests/TestPoisonArea.cpp |   54 +++++++++++++++++++++++++++++++--
 1 files changed, 50 insertions(+), 4 deletions(-)

diff --git a/layout/base/tests/TestPoisonArea.cpp b/layout/base/tests/TestPoisonArea.cpp
index 67cb211..5227858 100644
--- a/layout/base/tests/TestPoisonArea.cpp
+++ b/layout/base/tests/TestPoisonArea.cpp
@@ -156,6 +156,8 @@ typedef unsigned int uint32_t;
 
 /* This program assumes that a whole number of return instructions fit into
  * 32 bits, and that 32-bit alignment is sufficient for a branch destination.
+ * For architectures where this is not true, fiddling with RETURN_INSTR_TYPE
+ * can be enough.
  */
 
 #if defined __i386__ || defined __x86_64__ ||   \
@@ -174,10 +176,40 @@ typedef unsigned int uint32_t;
 #elif defined __sparc || defined __sparcv9
 #define RETURN_INSTR 0x81c3e008 /* retl */
 
+#elif defined __alpha
+#define RETURN_INSTR 0x6bfa8001 /* ret */
+
+#elif defined __hppa
+#define RETURN_INSTR 0xe840c002 /* bv,n r0(rp) */
+
+#elif defined __mips
+#define RETURN_INSTR 0x03e00008 /* jr ra */
+
+#ifdef __MIPSEL
+/* On mipsel, jr ra needs to be followed by a nop.
+   0x03e00008 as a 64 bits integer just does that */
+#define RETURN_INSTR_TYPE uint64_t
+#endif
+
+#elif defined __s390__
+#define RETURN_INSTR 0x07fe0000 /* br %r14 */
+
+#elif defined __ia64
+struct ia64_instr { uint32_t i[4]; };
+static const ia64_instr _return_instr =
+  {{ 0x00000011, 0x00000001, 0x80000200, 0x00840008 }}; /* br.ret.sptk.many b0 */
+
+#define RETURN_INSTR _return_instr
+#define RETURN_INSTR_TYPE ia64_instr
+
 #else
 #error "Need return instruction for this architecture"
 #endif
 
+#ifndef RETURN_INSTR_TYPE
+#define RETURN_INSTR_TYPE uint32_t
+#endif
+
 // Miscellaneous Windows/Unix portability gumph
 
 #ifdef _WIN32
@@ -376,8 +408,8 @@ ReserveNegativeControl()
   }
 
   // Fill the page with return instructions.
-  uint32_t *p = (uint32_t *)result;
-  uint32_t *limit = (uint32_t *)(((char *)result) + PAGESIZE);
+  RETURN_INSTR_TYPE *p = (RETURN_INSTR_TYPE *)result;
+  RETURN_INSTR_TYPE *limit = (RETURN_INSTR_TYPE *)(((char *)result) + PAGESIZE);
   while (p < limit)
     *p++ = RETURN_INSTR;
 
@@ -394,6 +426,20 @@ ReserveNegativeControl()
   return (uintptr_t)result;
 }
 
+static void
+JumpTo(uintptr_t opaddr)
+{
+#ifdef __ia64
+  struct func_call {
+    uintptr_t func;
+    uintptr_t gp;
+  } call = { opaddr, };
+  ((void (*)())&call)();
+#else
+  ((void (*)())opaddr)();
+#endif
+}
+
 /* Test each page.  */
 static bool
 TestPage(const char *pagelabel, uintptr_t pageaddr, int should_succeed)
@@ -417,7 +463,7 @@ TestPage(const char *pagelabel, uintptr_t pageaddr, int should_succeed)
       unsigned char scratch;
       switch (test) {
       case 0: scratch = *(volatile unsigned char *)opaddr; break;
-      case 1: ((void (*)())opaddr)(); break;
+      case 1: JumpTo(opaddr); break;
       case 2: *(volatile unsigned char *)opaddr = 0; break;
       default: abort();
       }
@@ -451,7 +497,7 @@ TestPage(const char *pagelabel, uintptr_t pageaddr, int should_succeed)
       volatile unsigned char scratch;
       switch (test) {
       case 0: scratch = *(volatile unsigned char *)opaddr; break;
-      case 1: ((void (*)())opaddr)(); break;
+      case 1: JumpTo(opaddr); break;
       case 2: *(volatile unsigned char *)opaddr = 0; break;
       default: abort();
       }
